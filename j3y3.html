<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Á∂ìÂÖ∏‰∫îÂ≠êÊ£ã - Â∞ëÂ•≥Á≤âÁ¥ÖÁâà</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #fff0f5; /* LavenderBlush */
            font-family: "Microsoft JhengHei", "Heiti TC", sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            /* Polka dot pattern in pink */
            background-image: radial-gradient(#ffb6c1 15%, transparent 15%), radial-gradient(#ffb6c1 15%, transparent 15%);
            background-position: 0 0, 15px 15px;
            background-size: 30px 30px;
            overflow-x: hidden; /* Important for the runner animation */
        }

        #game-container {
            position: relative;
            box-shadow: 0 15px 35px rgba(255, 105, 180, 0.4); /* Pink glow shadow */
            border-radius: 15px;
            padding: 20px;
            background: #ffc0cb;
            /* Strawberry Milk Gradient */
            background: linear-gradient(135deg, #ffe4e1 0%, #ffb6c1 100%);
            border: 4px solid #fff;
            transition: transform 0.1s;
        }

        /* Shake Animation */
        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            10% { transform: translate(-1px, -2px) rotate(-1deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            30% { transform: translate(3px, 2px) rotate(0deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            70% { transform: translate(3px, 1px) rotate(-1deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            90% { transform: translate(1px, 2px) rotate(0deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }

        .shake-effect {
            animation: shake 0.5s;
            animation-iteration-count: 1;
        }

        canvas {
            display: block;
            cursor: pointer;
            border-radius: 8px;
            touch-action: none;
            background-color: transparent; 
        }

        #ui-layer {
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            width: 600px;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .card {
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 20px;
            border-radius: 20px;
            box-shadow: 0 4px 10px rgba(255, 182, 193, 0.3);
            display: flex;
            align-items: center;
            gap: 10px;
            border: 2px solid #ffe4e1;
        }

        h1 { margin: 0; font-size: 1.5rem; color: #d63384; /* Dark Pink */ }

        .turn-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: bold;
            font-size: 1.1rem;
            color: #d63384;
        }

        .stone-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: inline-block;
            border: 1px solid rgba(0,0,0,0.1);
        }
        .stone-black { background: radial-gradient(circle at 30% 30%, #555, #222); }
        .stone-white { background: radial-gradient(circle at 30% 30%, #fff, #f0f0f0); border: 1px solid #ffb6c1; }

        /* Controls */
        .controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        select, button {
            padding: 8px 15px;
            font-size: 0.95rem;
            border-radius: 20px;
            border: 2px solid #ffb6c1;
            font-family: inherit;
            cursor: pointer;
            outline: none;
        }
        
        select {
            background-color: #fff;
            color: #d63384;
        }

        button {
            background-color: #ff69b4; /* Hot Pink */
            color: white;
            border: none;
            font-weight: bold;
            box-shadow: 0 4px 0 #db7093; /* 3D effect */
            transition: transform 0.1s, box-shadow 0.1s;
        }
        button:active {
            transform: translateY(4px);
            box-shadow: 0 0 0 #db7093;
        }
        button:hover { background-color: #ff1493; }

        .toggle-label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.95rem;
            background: #fff;
            padding: 8px 15px;
            border-radius: 20px;
            border: 2px solid #ffb6c1;
            cursor: pointer;
            user-select: none;
            color: #d63384;
        }
        .toggle-label input { cursor: pointer; width: 16px; height: 16px; accent-color: #ff69b4; }

        /* Modal */
        #modal-overlay {
            display: none;
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255, 192, 203, 0.6); /* Pinkish overlay */
            backdrop-filter: blur(2px);
            justify-content: center;
            align-items: center;
            border-radius: 15px;
            z-index: 10;
        }

        #modal-content {
            background: white;
            padding: 40px;
            border-radius: 25px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(219, 112, 147, 0.3);
            border: 4px solid #ffb6c1;
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes popIn { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        #winner-text { font-size: 2rem; margin-bottom: 20px; color: #ff1493; }

        /* --- Full Screen Disaster Alert --- */
        #disaster-alert {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            
            font-size: 5rem; 
            font-weight: 900;
            width: 100%;
            text-align: center;
            background: rgba(50, 0, 20, 0.7); /* Dark reddish background */
            padding: 40px 0;
            
            opacity: 0;
            transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.4s;
            pointer-events: none;
            z-index: 50;
            
            white-space: nowrap;
            text-shadow: 0 0 30px currentColor;
        }
        
        #disaster-alert.active {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }

        /* --- Start Game Overlay --- */
        #start-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(3px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 20;
            border-radius: 11px;
        }

        #start-btn {
            font-size: 2rem;
            padding: 15px 50px;
            border-radius: 50px;
            background-color: #ff1493;
            color: white;
            border: 4px solid #fff;
            box-shadow: 0 0 15px #ff69b4, 0 6px 0 #c71585;
            cursor: pointer;
            animation: pulse 1.5s infinite ease-in-out;
            text-shadow: 2px 2px 0 rgba(0,0,0,0.1);
        }

        #start-btn:hover {
            transform: scale(1.05);
            background-color: #ff0080;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        /* --- Start Game Runner Animation --- */
        #start-runner {
            position: fixed;
            top: 50%;
            left: 100vw; /* Start off-screen right */
            transform: translateY(-50%);
            height: 350px; /* Big enough to be seen */
            z-index: 9999; /* Top most */
            pointer-events: none; /* Let clicks pass through */
            display: none; /* Hidden by default */
        }

        #start-runner.active {
            display: block;
            animation: run-across 2.5s linear forwards;
        }

        @keyframes run-across {
            0% { left: 100vw; }
            100% { left: -600px; } /* Run until fully off-screen left */
        }

        @media (max-width: 650px) {
            #ui-layer { width: 95vw; flex-direction: column; align-items: stretch; }
            canvas { width: 95vw; height: 95vw; }
            .controls { flex-direction: column; align-items: stretch; }
            .toggle-label { justify-content: center; }
            #disaster-alert { font-size: 2.5rem; padding: 20px 0; }
            #start-runner { height: 180px; } /* Smaller runner on mobile */
        }
    </style>
</head>
<body>

    <!-- Runner Image (Hidden initially) -->
    <img id="start-runner" src="https://popokoko.github.io/love_us_run-removebg-preview.png" alt="Let's Go!">

    <div id="ui-layer">
        <div class="card">
            <h1>üå∏ Â∞ëÂ•≥‰∫îÂ≠êÊ£ã</h1>
        </div>
        
        <div class="card">
            <div class="turn-indicator">
                <span id="current-stone" class="stone-icon stone-black"></span>
                <span id="status-text">ÈªëÂ≠êÂõûÂêà</span>
            </div>
        </div>

        <div class="controls">
            <select id="game-mode">
                <option value="pve">‰∫∫Ê©üÂ∞çÊà∞</option>
                <option value="pvp">Èõô‰∫∫Â∞çÊà∞</option>
            </select>
            <select id="ai-level">
                <option value="1">AI: Á∞°ÂñÆ</option>
                <option value="2" selected>AI: ÊôÆÈÄö</option>
                <option value="3">AI: Â§ßÂ∏´</option>
            </select>
            <label class="toggle-label" title="Èö®Ê©üÂá∫ÁèæÁâπÊïàÁÅΩÂÆ≥">
                <input type="checkbox" id="disaster-toggle"> üå™Ô∏è ÂãïÊÖãÂ§©ÁÅΩ
            </label>
            <button onclick="resetGame()">ÈáçÊñ∞ÈñãÂßã</button>
        </div>
    </div>

    <div id="game-container">
        <!-- Start Overlay -->
        <div id="start-overlay">
            <button id="start-btn" onclick="startGame()">üíñ ÈñãÂßãÂ∞çÊà∞</button>
        </div>

        <div id="disaster-alert">‚ö†Ô∏è Â§©ÁÅΩÈ†êË≠¶ÔºÅ</div>
        <canvas id="board" width="600" height="600"></canvas>
        <div id="modal-overlay">
            <div id="modal-content">
                <div id="winner-text">ÈªëÂ≠êÁç≤Âãù!</div>
                <button onclick="resetGame()">ÂÜç‰æÜ‰∏ÄÂ±Ä</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('board');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('game-container');
        const statusText = document.getElementById('status-text');
        const currentStoneIcon = document.getElementById('current-stone');
        const modal = document.getElementById('modal-overlay');
        const winnerText = document.getElementById('winner-text');
        const modeSelect = document.getElementById('game-mode');
        const levelSelect = document.getElementById('ai-level');
        const disasterToggle = document.getElementById('disaster-toggle');
        const disasterAlert = document.getElementById('disaster-alert');
        const startOverlay = document.getElementById('start-overlay');
        const startRunner = document.getElementById('start-runner');

        // Load Custom Image for Disaster
        const customImage = new Image();
        customImage.src = 'https://popokoko.github.io/mywife.png';

        // Game Constants
        const GRID_SIZE = 15;
        let CELL_SIZE = 600 / (GRID_SIZE + 1);
        let PADDING = CELL_SIZE;

        // Game State
        // Board Values: 
        // 0: Empty
        // 1: Black, 2: White
        // -1: Meteor Crater
        // -2: Tornado Debris
        // -3: Love/Custom Image
        // -4: Tear Puddle
        let board = [];
        let currentPlayer = 1;
        let isGameOver = false;
        let lastMove = null;
        let isThinking = false;
        let isGameActive = false; // Controls if the game has started
        
        // Disaster & Animation State
        let disasterTimeoutId = null;
        let particles = [];
        let activeEffects = []; 
        let animationFrameId = null;

        function init() {
            const dpr = window.devicePixelRatio || 1;
            canvas.width = 600 * dpr;
            canvas.height = 600 * dpr;
            ctx.scale(dpr, dpr);
            
            CELL_SIZE = 600 / (GRID_SIZE + 1);
            PADDING = CELL_SIZE;

            // Initial Draw without starting logic
            board = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
            draw();
            
            canvas.addEventListener('click', handleInput);
            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                handleInput(e.changedTouches[0]);
            }, {passive: false});

            modeSelect.addEventListener('change', () => {
                levelSelect.style.display = modeSelect.value === 'pve' ? 'inline-block' : 'none';
                if(isGameActive) resetGame();
            });
            
            disasterToggle.addEventListener('change', () => {
                if (isGameActive) {
                    if (disasterToggle.checked) {
                        scheduleNextDisaster();
                    } else {
                        clearTimeout(disasterTimeoutId);
                    }
                }
            });

            // Start Animation Loop
            animate();
        }

        function startGame() {
            startOverlay.style.display = 'none';
            isGameActive = true;
            
            // Trigger Runner Animation
            startRunner.classList.remove('active');
            void startRunner.offsetWidth; // Trigger reflow
            startRunner.classList.add('active');
            
            // Cleanup animation class after it finishes (3s)
            setTimeout(() => {
                startRunner.classList.remove('active');
            }, 3000);

            resetGame();
        }

        function resetGame() {
            if (!isGameActive) return;

            board = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
            currentPlayer = 1;
            isGameOver = false;
            lastMove = null;
            isThinking = false;
            modal.style.display = 'none';
            particles = [];
            activeEffects = [];
            
            clearTimeout(disasterTimeoutId);
            if (disasterToggle.checked) {
                scheduleNextDisaster();
            }

            updateUI();
        }

        function updateUI() {
            if (currentPlayer === 1) {
                statusText.textContent = "ÈªëÂ≠êÂõûÂêà";
                currentStoneIcon.className = "stone-icon stone-black";
            } else {
                const mode = modeSelect.value;
                statusText.textContent = mode === 'pve' ? "ÈõªËÖ¶ÊÄùËÄÉ‰∏≠..." : "ÁôΩÂ≠êÂõûÂêà";
                currentStoneIcon.className = "stone-icon stone-white";
            }
        }

        // --- Disaster Logic ---
        
        function scheduleNextDisaster() {
            if (isGameOver || !disasterToggle.checked || !isGameActive) return;
            
            // Chaos happens more often: 4s to 12s
            const delay = Math.floor(Math.random() * 8000) + 4000;
            
            disasterTimeoutId = setTimeout(() => {
                triggerDisaster();
                scheduleNextDisaster();
            }, delay);
        }

        function triggerDisaster() {
            if (isGameOver || !isGameActive) return;

            const x = Math.floor(Math.random() * GRID_SIZE);
            const y = Math.floor(Math.random() * GRID_SIZE);

            // Random Disaster Type
            const types = [
                { id: -1, name: 'meteor', text: 'üî• ÈöïÁü≥Ë°ùÊìäÔºÅ', color: '#FF4500' },
                { id: -2, name: 'tornado', text: 'üå™Ô∏è ÈæçÊç≤È¢®‰æÜË•≤ÔºÅ', color: '#00FFFF' },
                { id: -3, name: 'love', text: 'üíñ ËÄÅÂ©ÜÈôçËá®ÔºÅ', color: '#FF69B4' },
                { id: -4, name: 'tear', text: 'üíß Áõ∏ÊÄùÊàêÁÅΩ...', color: '#4169E1' }
            ];
            
            const disaster = types[Math.floor(Math.random() * types.length)];

            // Start Animation Effect
            spawnDisasterEffect(disaster, x, y);
            
            // Show Alert
            showAlert(disaster.text, disaster.color);
        }

        function spawnDisasterEffect(disaster, gridX, gridY) {
            const targetX = PADDING + gridX * CELL_SIZE;
            const targetY = PADDING + gridY * CELL_SIZE;

            // Add to active effects for animation
            activeEffects.push({
                type: disaster.name,
                gridX: gridX,
                gridY: gridY,
                disasterId: disaster.id,
                progress: 0,
                x: disaster.name === 'meteor' || disaster.name === 'love' || disaster.name === 'tear' ? targetX : targetX - 100, // Start pos
                y: disaster.name === 'meteor' || disaster.name === 'love' || disaster.name === 'tear' ? -50 : targetY, 
                targetX: targetX,
                targetY: targetY
            });
        }

        function applyDisasterDamage(effect) {
            // Apply permanent board change
            board[effect.gridY][effect.gridX] = effect.disasterId;
            
            // Screen Shake
            gameContainer.classList.remove('shake-effect');
            void gameContainer.offsetWidth;
            gameContainer.classList.add('shake-effect');

            // Explosion Particles
            spawnParticles(effect.targetX, effect.targetY, effect.type);
        }

        function spawnParticles(x, y, type) {
            let count = 20;
            let color = '#fff';
            
            if (type === 'meteor') { count = 30; color = '#ffaa00'; }
            else if (type === 'tornado') { count = 20; color = '#88ffff'; }
            else if (type === 'love') { count = 15; color = '#ff69b4'; }
            else if (type === 'tear') { count = 15; color = '#4169e1'; }

            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 1.0,
                    color: color,
                    type: type
                });
            }
        }

        function showAlert(text, color) {
            disasterAlert.textContent = text;
            disasterAlert.style.color = color;
            // Add text shadow glow effect matching the color
            disasterAlert.style.textShadow = `0 0 20px ${color}, 2px 2px 0 #000`;
            
            // Trigger animation class
            disasterAlert.classList.add('active');
            
            // Remove after delay
            setTimeout(() => { 
                disasterAlert.classList.remove('active');
            }, 2000);
        }

        // --- Animation Loop ---

        function animate() {
            // Always clear and redraw to handle particles/effects
            draw(); 
            updateEffects();
            requestAnimationFrame(animate);
        }

        function updateEffects() {
            // Update Active Effects (Falling/Moving)
            for (let i = activeEffects.length - 1; i >= 0; i--) {
                let eff = activeEffects[i];
                
                if (eff.type === 'meteor') {
                    // Fall down
                    eff.y += 15; 
                    if (eff.y >= eff.targetY) {
                        applyDisasterDamage(eff);
                        activeEffects.splice(i, 1);
                    }
                } 
                else if (eff.type === 'love') {
                    // Float down slowly (Image float)
                    eff.y += 5;
                    if (eff.y >= eff.targetY) {
                        applyDisasterDamage(eff);
                        activeEffects.splice(i, 1);
                    }
                }
                else if (eff.type === 'tear') {
                    // Rain down
                    eff.y += 8;
                    if (eff.y >= eff.targetY) {
                        applyDisasterDamage(eff);
                        activeEffects.splice(i, 1);
                    }
                }
                else if (eff.type === 'tornado') {
                    // Move horizontally
                    eff.x += (eff.targetX - eff.x) * 0.1;
                    eff.progress += 0.05;
                    if (Math.abs(eff.x - eff.targetX) < 5 && eff.progress > 1) {
                        applyDisasterDamage(eff);
                        activeEffects.splice(i, 1);
                    }
                }
            }

            // Update Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.02;
                
                // Gravity for some
                if (p.type === 'tear' || p.type === 'meteor') p.vy += 0.2;

                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        // --- Drawing Functions ---

        function draw() {
            ctx.clearRect(0, 0, 600, 600);

            // 1. Draw Grid
            ctx.beginPath();
            ctx.lineWidth = 1;
            // Changed grid line color to soft raspberry
            ctx.strokeStyle = "#8B4C5E"; 
            for (let i = 0; i < GRID_SIZE; i++) {
                ctx.moveTo(PADDING, PADDING + i * CELL_SIZE);
                ctx.lineTo(PADDING + (GRID_SIZE - 1) * CELL_SIZE, PADDING + i * CELL_SIZE);
                ctx.moveTo(PADDING + i * CELL_SIZE, PADDING);
                ctx.lineTo(PADDING + i * CELL_SIZE, PADDING + (GRID_SIZE - 1) * CELL_SIZE);
            }
            ctx.stroke();

            // 2. Draw Stars
            const stars = [{x: 3, y: 3}, {x: 11, y: 3}, {x: 7, y: 7}, {x: 3, y: 11}, {x: 11, y: 11}];
            ctx.fillStyle = "#8B4C5E";
            stars.forEach(star => {
                ctx.beginPath();
                ctx.arc(PADDING + star.x * CELL_SIZE, PADDING + star.y * CELL_SIZE, 4, 0, Math.PI * 2);
                ctx.fill();
            });

            // 3. Draw Board Objects (Stones & Disasters)
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const val = board[y][x];
                    if (val > 0) drawStone(x, y, val);
                    else if (val < 0) drawDisasterResult(x, y, val);
                }
            }

            // 4. Highlight Last Move
            if (lastMove && board[lastMove.y][lastMove.x] > 0) {
                ctx.beginPath();
                const cx = PADDING + lastMove.x * CELL_SIZE;
                const cy = PADDING + lastMove.y * CELL_SIZE;
                ctx.fillStyle = "#ff1493"; // Deep pink highlight
                ctx.fillRect(cx - 4, cy - 4, 8, 8);
            }

            // 5. Draw Active Effects (In Flight)
            drawActiveEffects();

            // 6. Draw Particles
            drawParticles();
        }

        function drawStone(x, y, type) {
            const cx = PADDING + x * CELL_SIZE;
            const cy = PADDING + y * CELL_SIZE;
            const radius = CELL_SIZE * 0.45;
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, Math.PI * 2);
            ctx.shadowColor = "rgba(0, 0, 0, 0.2)"; // Softer shadow
            ctx.shadowBlur = 5;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;
            const grad = ctx.createRadialGradient(cx - radius/3, cy - radius/3, radius/10, cx, cy, radius);
            if (type === 1) { 
                // Black stone: Dark Chocolate
                grad.addColorStop(0, "#554444"); 
                grad.addColorStop(1, "#1a1a1a"); 
            } else { 
                // White stone: Cream
                grad.addColorStop(0, "#fff"); 
                grad.addColorStop(1, "#f0e0e0"); 
            }
            ctx.fillStyle = grad;
            ctx.fill();
            ctx.shadowColor = "transparent";
        }

        function drawDisasterResult(x, y, type) {
            const cx = PADDING + x * CELL_SIZE;
            const cy = PADDING + y * CELL_SIZE;
            const size = CELL_SIZE * 0.4;
            
            ctx.save();
            ctx.translate(cx, cy);

            if (type === -1) { // Meteor Crater
                ctx.fillStyle = "#444";
                ctx.beginPath();
                ctx.arc(0, 0, size, 0, Math.PI*2);
                ctx.fill();
                ctx.strokeStyle = "#FF4500";
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-size*0.7, -size*0.7); ctx.lineTo(size*0.7, size*0.7);
                ctx.moveTo(size*0.7, -size*0.7); ctx.lineTo(-size*0.7, size*0.7);
                ctx.stroke();
            } else if (type === -2) { // Tornado Debris
                ctx.fillStyle = "#aaa";
                ctx.beginPath();
                ctx.arc(0, 0, size*0.8, 0, Math.PI*2);
                ctx.fill();
                ctx.strokeStyle = "#555";
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, size*0.5, 0, Math.PI*1.5);
                ctx.stroke();
            } else if (type === -3) { // Love/Custom Image Debris
                if (customImage.complete) {
                    // Draw circular clipped image
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 1.2, 0, Math.PI * 2);
                    ctx.clip();
                    ctx.drawImage(customImage, -size*1.2, -size*1.2, size*2.4, size*2.4);
                } else {
                    // Fallback to Heart
                    ctx.fillStyle = "#FF69B4";
                    ctx.beginPath();
                    const topCurveHeight = size * 0.3;
                    ctx.moveTo(0, topCurveHeight);
                    ctx.bezierCurveTo(0, 0, -size, 0, -size, topCurveHeight);
                    ctx.bezierCurveTo(-size, (size + topCurveHeight) / 2, 0, size, 0, size + topCurveHeight);
                    ctx.bezierCurveTo(0, size, size, (size + topCurveHeight) / 2, size, topCurveHeight);
                    ctx.bezierCurveTo(size, 0, 0, 0, 0, topCurveHeight);
                    ctx.fill();
                }
            } else if (type === -4) { // Tear Puddle
                ctx.fillStyle = "#4169E1";
                ctx.beginPath();
                ctx.arc(0, size*0.4, size*0.6, 0, Math.PI*2);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(0, -size);
                ctx.quadraticCurveTo(size*0.6, size*0.4, 0, size*0.4);
                ctx.quadraticCurveTo(-size*0.6, size*0.4, 0, -size);
                ctx.fill();
            }
            ctx.restore();
        }

        function drawActiveEffects() {
            activeEffects.forEach(eff => {
                ctx.save();
                ctx.translate(eff.x, eff.y);

                if (eff.type === 'meteor') {
                    const grad = ctx.createRadialGradient(0, 0, 5, 0, 0, 20);
                    grad.addColorStop(0, '#ffff00');
                    grad.addColorStop(0.5, '#ffaa00');
                    grad.addColorStop(1, 'transparent');
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(0, 0, 20, 0, Math.PI*2);
                    ctx.fill();
                } 
                else if (eff.type === 'tornado') {
                    ctx.rotate(Date.now() / 100);
                    ctx.strokeStyle = "rgba(0, 255, 255, 0.6)";
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    for(let i=0; i<3; i++) {
                        ctx.arc(0, i*5, 10 + i*5, 0, Math.PI);
                    }
                    ctx.stroke();
                }
                else if (eff.type === 'love') {
                    // Falling Custom Image
                    if (customImage.complete) {
                        ctx.drawImage(customImage, -30, -30, 60, 60);
                    } else {
                        ctx.fillStyle = "#FF1493";
                        ctx.font = "30px Arial";
                        ctx.fillText("‚ù§", -15, 10);
                    }
                }
                else if (eff.type === 'tear') {
                    ctx.fillStyle = "#00BFFF";
                    ctx.font = "30px Arial";
                    ctx.fillText("üíß", -15, 10);
                }

                ctx.restore();
            });
        }

        function drawParticles() {
            particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                
                if (p.type === 'love') {
                     // Love particles also
                    ctx.font = "12px Arial";
                    ctx.fillText("‚ù§", p.x, p.y);
                } else if (p.type === 'tornado') {
                    ctx.rect(p.x, p.y, 3, 3);
                    ctx.fill();
                } else {
                    ctx.arc(p.x, p.y, 3, 0, Math.PI*2);
                    ctx.fill();
                }
            });
            ctx.globalAlpha = 1.0;
        }

        // --- Logic & Input (Same as before) ---

        function handleInput(e) {
            if (isGameOver || isThinking || !isGameActive) return;
            if (modeSelect.value === 'pve' && currentPlayer === 2) return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = 600 / rect.width;
            const scaleY = 600 / rect.height;
            const mouseX = (e.clientX - rect.left) * scaleX;
            const mouseY = (e.clientY - rect.top) * scaleY;

            const gridX = Math.round((mouseX - PADDING) / CELL_SIZE);
            const gridY = Math.round((mouseY - PADDING) / CELL_SIZE);

            if (gridX >= 0 && gridX < GRID_SIZE && gridY >= 0 && gridY < GRID_SIZE) {
                if (board[gridY][gridX] === 0) {
                    placeStone(gridX, gridY);
                }
            }
        }

        function placeStone(x, y) {
            board[y][x] = currentPlayer;
            lastMove = {x, y};
            
            if (checkWin(x, y, currentPlayer)) {
                endGame(currentPlayer);
                return;
            }

            currentPlayer = currentPlayer === 1 ? 2 : 1;
            updateUI();

            if (modeSelect.value === 'pve' && currentPlayer === 2 && !isGameOver) {
                isThinking = true;
                setTimeout(makeAIMove, 500);
            }
        }

        function makeAIMove() {
            if (!isGameActive || isGameOver) return; // Safety check
            
            const level = parseInt(levelSelect.value);
            let move;
            if (level === 1) move = getLevel1Move();
            else if (level === 2) move = getLevel2Move();
            else move = getLevel3Move();

            if (!move) {
                for(let y=0; y<GRID_SIZE; y++) {
                    for(let x=0; x<GRID_SIZE; x++) {
                        if(board[y][x] === 0) { move = {x, y}; break; }
                    }
                    if(move) break;
                }
            }
            
            if (move) placeStone(move.x, move.y);
            isThinking = false;
        }

        function getLevel1Move() {
            let candidates = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (board[y][x] === 0 && hasNeighbor(x, y, 2)) {
                        candidates.push({x, y});
                    }
                }
            }
            if (candidates.length === 0) {
                if (board[7][7] === 0) return {x: 7, y: 7};
                return null; 
            }
            return candidates[Math.floor(Math.random() * candidates.length)];
        }

        function getLevel2Move() { return getBestMoveByScore(false); }
        function getLevel3Move() { return getBestMoveByScore(true); }

        function getBestMoveByScore(isHard) {
            let bestScore = -Infinity;
            let bestMoves = [];
            
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (board[y][x] === 0) {
                        if (!hasNeighbor(x, y, 2) && board[7][7] !== 0) continue;
                        let attackScore = evaluatePoint(x, y, 2);
                        let defenseScore = evaluatePoint(x, y, 1);
                        let currentScore;
                        if (isHard) {
                            if (attackScore >= 10000) currentScore = 20000; 
                            else if (defenseScore >= 10000) currentScore = 10000; 
                            else currentScore = attackScore + defenseScore;
                        } else {
                            let noise = Math.random() * 20;
                            currentScore = attackScore + (defenseScore * 0.8) + noise;
                        }
                        if (currentScore > bestScore) {
                            bestScore = currentScore;
                            bestMoves = [{x, y}];
                        } else if (currentScore === bestScore) {
                            bestMoves.push({x, y});
                        }
                    }
                }
            }
            if (bestMoves.length === 0) {
                if (board[7][7] === 0) return {x: 7, y: 7};
                return null;
            }
            return bestMoves[Math.floor(Math.random() * bestMoves.length)];
        }

        function hasNeighbor(x, y, radius) {
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    let nx = x + dx, ny = y + dy;
                    if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                        if (board[ny][nx] !== 0) return true;
                    }
                }
            }
            return false;
        }

        function evaluatePoint(x, y, player) {
            let score = 0;
            const dirs = [[1,0], [0,1], [1,1], [1,-1]];
            for (let dir of dirs) {
                score += evaluateLine(x, y, dir[0], dir[1], player);
            }
            return score;
        }

        function evaluateLine(x, y, dx, dy, player) {
            let count = 1; 
            let blockedEnds = 0;
            let i = 1;
            while (true) {
                let nx = x + dx * i;
                let ny = y + dy * i;
                if (nx < 0 || nx >= GRID_SIZE || ny < 0 || ny >= GRID_SIZE) { blockedEnds++; break; }
                const val = board[ny][nx];
                if (val === player) { count++; }
                else if (val === 0) { break; } 
                else { blockedEnds++; break; } 
                i++;
            }
            i = 1;
            while (true) {
                let nx = x - dx * i;
                let ny = y - dy * i;
                if (nx < 0 || nx >= GRID_SIZE || ny < 0 || ny >= GRID_SIZE) { blockedEnds++; break; }
                const val = board[ny][nx];
                if (val === player) { count++; }
                else if (val === 0) { break; }
                else { blockedEnds++; break; }
                i++;
            }
            if (blockedEnds >= 2 && count < 5) return 0;
            if (count >= 5) return 100000;
            if (count === 4) return blockedEnds === 0 ? 10000 : 2500;
            if (count === 3) return blockedEnds === 0 ? 3000 : 500;
            if (count === 2) return blockedEnds === 0 ? 500 : 50;
            return 10;
        }

        function checkWin(x, y, player) {
            const directions = [[1, 0], [0, 1], [1, 1], [1, -1]];
            for (let [dx, dy] of directions) {
                let count = 1;
                for (let i = 1; i < 5; i++) {
                    const nx = x + dx * i, ny = y + dy * i;
                    if (nx < 0 || nx >= GRID_SIZE || ny < 0 || ny >= GRID_SIZE || board[ny][nx] !== player) break;
                    count++;
                }
                for (let i = 1; i < 5; i++) {
                    const nx = x - dx * i, ny = y - dy * i;
                    if (nx < 0 || nx >= GRID_SIZE || ny < 0 || ny >= GRID_SIZE || board[ny][nx] !== player) break;
                    count++;
                }
                if (count >= 5) return true;
            }
            return false;
        }

        function endGame(winner) {
            isGameOver = true;
            clearTimeout(disasterTimeoutId);
            let msg = winner === 1 ? "ÈªëÂ≠êÁç≤Âãù!" : "ÁôΩÂ≠êÁç≤Âãù!";
            if (modeSelect.value === 'pve' && winner === 2) msg = "ÈõªËÖ¶Áç≤Âãù!";
            winnerText.textContent = msg;
            modal.style.display = 'flex';
            statusText.textContent = "ÈÅäÊà≤ÁµêÊùü";
        }

        init();

    </script>
</body>
</html>
