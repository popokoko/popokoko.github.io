<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¶“å…¸äº”å­æ£‹ - å°‘å¥³ç²‰ç´…ç‰ˆ (é˜²å´©æ½°ç‰ˆ)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #fff0f5;
            font-family: "Microsoft JhengHei", "Heiti TC", sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-image: radial-gradient(#ffb6c1 15%, transparent 15%), radial-gradient(#ffb6c1 15%, transparent 15%);
            background-position: 0 0, 15px 15px;
            background-size: 30px 30px;
            overflow-x: hidden;
            user-select: none;
        }

        #game-container {
            position: relative;
            box-shadow: 0 15px 35px rgba(255, 105, 180, 0.4);
            border-radius: 15px;
            padding: 20px;
            background: #ffc0cb;
            background: linear-gradient(135deg, #ffe4e1 0%, #ffb6c1 100%);
            border: 4px solid #fff;
            transition: transform 0.1s;
            overflow: hidden;
        }

        @keyframes shake {
            0% {
                transform: translate(1px, 1px) rotate(0deg);
            }

            10% {
                transform: translate(-1px, -2px) rotate(-1deg);
            }

            20% {
                transform: translate(-3px, 0px) rotate(1deg);
            }

            30% {
                transform: translate(3px, 2px) rotate(0deg);
            }

            40% {
                transform: translate(1px, -1px) rotate(1deg);
            }

            50% {
                transform: translate(-1px, 2px) rotate(-1deg);
            }

            60% {
                transform: translate(-3px, 1px) rotate(0deg);
            }

            70% {
                transform: translate(3px, 1px) rotate(-1deg);
            }

            80% {
                transform: translate(-1px, -1px) rotate(1deg);
            }

            90% {
                transform: translate(1px, 2px) rotate(0deg);
            }

            100% {
                transform: translate(1px, -2px) rotate(-1deg);
            }
        }

        .shake-effect {
            animation: shake 0.5s;
            animation-iteration-count: 1;
        }

        .blur-effect canvas {
            filter: blur(8px);
            transition: filter 0.5s;
        }

        .freeze-effect canvas {
            filter: hue-rotate(180deg) brightness(1.2);
            transition: filter 0.5s;
        }

        canvas {
            display: block;
            cursor: pointer;
            border-radius: 8px;
            touch-action: none;
            background-color: transparent;
            transition: filter 0.3s;
        }

        #ui-layer {
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            width: 600px;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .card {
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 20px;
            border-radius: 20px;
            box-shadow: 0 4px 10px rgba(255, 182, 193, 0.3);
            display: flex;
            align-items: center;
            gap: 10px;
            border: 2px solid #ffe4e1;
        }

        h1 {
            margin: 0;
            font-size: 1.5rem;
            color: #d63384;
        }

        .dowry-display {
            font-weight: bold;
            color: #d63384;
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 1.1rem;
        }

        .dowry-icon {
            font-size: 1.2rem;
        }

        .turn-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: bold;
            font-size: 1.1rem;
            color: #d63384;
        }

        .stone-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: inline-block;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        .stone-black {
            background: radial-gradient(circle at 30% 30%, #555, #222);
        }

        .stone-white {
            background: radial-gradient(circle at 30% 30%, #fff, #f0f0f0);
            border: 1px solid #ffb6c1;
        }

        .controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        select,
        button {
            padding: 8px 15px;
            font-size: 0.95rem;
            border-radius: 20px;
            border: 2px solid #ffb6c1;
            font-family: inherit;
            cursor: pointer;
            outline: none;
        }

        select {
            background-color: #fff;
            color: #d63384;
        }

        button {
            background-color: #ff69b4;
            color: white;
            border: none;
            font-weight: bold;
            box-shadow: 0 4px 0 #db7093;
            transition: transform 0.1s, box-shadow 0.1s, background-color 0.2s, opacity 0.2s;
        }

        button:active {
            transform: translateY(4px);
            box-shadow: 0 0 0 #db7093;
        }

        button:hover {
            background-color: #ff1493;
        }

        button:disabled {
            background-color: #ffb6c1;
            box-shadow: none;
            cursor: not-allowed;
            opacity: 0.6;
            transform: none;
        }

        .btn-secondary {
            background-color: #fff;
            color: #ff69b4;
            border: 2px solid #ff69b4;
            box-shadow: 0 4px 0 #ffb6c1;
        }

        .btn-secondary:hover {
            background-color: #fff0f5;
            color: #ff1493;
        }

        .btn-secondary:active {
            box-shadow: 0 0 0 #ffb6c1;
        }

        .toggle-label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.95rem;
            background: #fff;
            padding: 8px 15px;
            border-radius: 20px;
            border: 2px solid #ffb6c1;
            cursor: pointer;
            user-select: none;
            color: #d63384;
        }

        .toggle-label input {
            cursor: pointer;
            width: 16px;
            height: 16px;
            accent-color: #ff69b4;
        }

        .modal-overlay {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 192, 203, 0.6);
            backdrop-filter: blur(2px);
            justify-content: center;
            align-items: center;
            border-radius: 15px;
            z-index: 100;
        }

        .modal-content {
            background: white;
            padding: 40px;
            border-radius: 25px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(219, 112, 147, 0.3);
            border: 4px solid #ffb6c1;
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            max-width: 600px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
        }

        .store-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .store-item {
            border: 2px solid #eee;
            border-radius: 10px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: all 0.2s;
        }

        .store-item:hover {
            border-color: #ff69b4;
            transform: translateY(-2px);
        }

        .store-item.active {
            border-color: #ff1493;
            background-color: #fff0f5;
            box-shadow: 0 0 10px rgba(255, 20, 147, 0.2);
        }

        .store-preview {
            width: 40px;
            height: 40px;
            margin-bottom: 10px;
            border-radius: 50%;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .store-name {
            font-weight: bold;
            font-size: 0.9rem;
            color: #555;
            margin-bottom: 5px;
        }

        .store-price {
            font-size: 0.85rem;
            color: #d63384;
            margin-bottom: 8px;
        }

        .store-btn {
            padding: 5px 10px;
            font-size: 0.8rem;
            width: 100%;
        }

        .help-content {
            text-align: left;
        }

        .help-content h2 {
            color: #ff1493;
            text-align: center;
            margin-top: 0;
            border-bottom: 2px dashed #ffb6c1;
            padding-bottom: 10px;
        }

        .help-item {
            margin-bottom: 15px;
        }

        .help-item h3 {
            color: #d63384;
            margin-bottom: 5px;
            font-size: 1.1rem;
        }

        .help-item p {
            color: #666;
            font-size: 0.9rem;
            margin: 0;
            line-height: 1.4;
        }

        @keyframes popIn {
            from {
                transform: scale(0.8);
                opacity: 0;
            }

            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        #winner-text {
            font-size: 2rem;
            margin-bottom: 20px;
            color: #ff1493;
        }

        #reward-text {
            font-size: 1.2rem;
            color: #d63384;
            margin-bottom: 20px;
            font-weight: bold;
        }

        #disaster-alert {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            font-size: 4rem;
            font-weight: 900;
            width: 100%;
            text-align: center;
            background: rgba(50, 0, 20, 0.7);
            padding: 40px 0;
            color: #fff;
            opacity: 0;
            transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.4s;
            pointer-events: none;
            z-index: 50;
            white-space: nowrap;
            text-shadow: 0 0 30px currentColor;
        }

        #disaster-alert.active {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }

        #toast-message {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            background: rgba(255, 20, 147, 0.95);
            color: white;
            padding: 15px 30px;
            border-radius: 50px;
            font-size: 1.1rem;
            font-weight: bold;
            z-index: 2000;
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            pointer-events: none;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            white-space: nowrap;
        }

        #toast-message.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        #start-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(3px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 20;
            border-radius: 11px;
        }

        #start-btn {
            font-size: 2rem;
            padding: 15px 50px;
            border-radius: 50px;
            background-color: #ff1493;
            color: white;
            border: 4px solid #fff;
            box-shadow: 0 0 15px #ff69b4, 0 6px 0 #c71585;
            cursor: pointer;
            animation: pulse 1.5s infinite ease-in-out;
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.1);
        }

        #start-btn:hover {
            transform: scale(1.05);
            background-color: #ff0080;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }

            100% {
                transform: scale(1);
            }
        }

        #tournament-overlay {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 240, 245, 0.98);
            z-index: 25;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 11px;
            padding: 20px;
            overflow-y: auto;
        }

        .tournament-title {
            font-size: 1.8rem;
            color: #d63384;
            margin-bottom: 20px;
            text-shadow: 1px 1px 0 #fff;
        }

        .tournament-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            width: 100%;
            max-width: 550px;
        }

        .opponent-card {
            background: white;
            border: 2px solid #ffb6c1;
            border-radius: 15px;
            padding: 15px;
            text-align: left;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .opponent-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(255, 105, 180, 0.3);
            border-color: #ff1493;
        }

        .opponent-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }

        .opponent-level {
            font-size: 0.8rem;
            background: #ff69b4;
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
        }

        .opponent-name {
            font-size: 1.1rem;
            color: #d63384;
            font-weight: bold;
        }

        .opponent-desc {
            font-size: 0.8rem;
            color: #888;
            margin-bottom: 5px;
            font-style: italic;
        }

        .opponent-skill {
            font-size: 0.85rem;
            color: #c71585;
            background: #fff0f5;
            padding: 5px;
            border-radius: 5px;
            border: 1px dashed #ffb6c1;
            margin-top: auto;
        }

        .opponent-skill strong {
            display: block;
            color: #ff1493;
        }

        .fog-cloud {
            position: absolute;
            width: 150px;
            height: 150px;
            background: radial-gradient(circle, rgba(255, 255, 255, 1) 0%, rgba(255, 255, 255, 0) 70%);
            opacity: 0.9;
            pointer-events: none;
            border-radius: 50%;
            animation: floatFog 5s infinite ease-in-out;
            z-index: 4;
        }

        @keyframes floatFog {

            0%,
            100% {
                transform: translate(0, 0);
            }

            50% {
                transform: translate(10px, 15px);
            }
        }

        #start-runner {
            position: fixed;
            top: 50%;
            left: 100vw;
            transform: translateY(-50%);
            height: 350px;
            z-index: 9999;
            pointer-events: none;
            display: none;
        }

        #start-runner.active {
            display: block;
            animation: run-across 2.5s linear forwards;
        }

        @keyframes run-across {
            0% {
                left: 100vw;
            }

            100% {
                left: -600px;
            }
        }

        @media (max-width: 650px) {
            #ui-layer {
                width: 95vw;
                flex-direction: column;
                align-items: stretch;
            }

            canvas {
                width: 95vw;
                height: 95vw;
            }

            .controls {
                flex-direction: column;
                align-items: stretch;
            }

            .toggle-label {
                justify-content: center;
            }

            #disaster-alert {
                font-size: 2.5rem;
                padding: 20px 0;
            }

            #start-runner {
                height: 180px;
            }

            .tournament-grid {
                grid-template-columns: 1fr;
                gap: 10px;
            }
        }
    </style>
</head>

<body>

    <!-- Runner Image (Hidden initially) -->
    <img id="start-runner" src="https://popokoko.github.io/love_us_run-removebg-preview.png" alt="Let's Go!">

    <!-- Toast Message -->
    <div id="toast-message">æç¤ºè¨Šæ¯</div>

    <div id="ui-layer">
        <div class="card">
            <h1>ğŸŒ¸ å°‘å¥³äº”å­æ£‹</h1>
        </div>

        <div class="card">
            <div class="dowry-display" title="ç›®å‰æ“æœ‰çš„å«å¦">
                <span class="dowry-icon">ğŸ</span> <span id="dowry-count">0</span> å«å¦
            </div>
        </div>

        <div class="controls">
            <select id="game-mode">
                <option value="pve">äººæ©Ÿå°æˆ°</option>
                <option value="pvp">é›™äººå°æˆ°</option>
                <option value="tournament">æˆ‘æƒ³å¦³å¤§è³½</option>
            </select>
            <select id="ai-level">
                <option value="1">AI: ç°¡å–®</option>
                <option value="2" selected>AI: æ™®é€š</option>
                <option value="3">AI: å¤§å¸«</option>
            </select>
            <label class="toggle-label" title="éš¨æ©Ÿå‡ºç¾ç‰¹æ•ˆç½å®³">
                <input type="checkbox" id="disaster-toggle"> ğŸŒªï¸ å‹•æ…‹å¤©ç½
            </label>
            <button id="reselect-btn" class="btn-secondary" onclick="window.reselectGame()">ğŸ”„ é‡æ–°é¸æ“‡</button>
            <button id="restart-btn" onclick="window.resetGame()" disabled>é‡æ–°é–‹å§‹</button>
            <button class="btn-secondary" onclick="window.showStore()">ğŸª å•†åŸ</button>
            <button class="btn-secondary" onclick="window.showHelp()">â“ èªªæ˜</button>
        </div>
    </div>

    <div id="game-container">
        <!-- Start Overlay -->
        <div id="start-overlay">
            <button id="start-btn" onclick="window.handleStartButtonClick()">ğŸ’– é–‹å§‹å°æˆ°</button>
        </div>

        <!-- Tournament Selection Overlay -->
        <div id="tournament-overlay">
            <div class="tournament-title">ğŸ† è«‹é¸æ“‡æ€å¿µç­‰ç´š</div>
            <div class="tournament-grid" id="tournament-grid">
                <!-- Generated by JS -->
            </div>
            <button
                style="margin-top:20px; background:#ccc; border:none; padding: 10px 30px; border-radius: 20px; color: white; font-weight: bold;"
                onclick="window.cancelTournament()">è¿”å›</button>
        </div>

        <!-- Modal Container (Generic for Help, Store, EndGame) -->
        <div id="modal-overlay" class="modal-overlay">
            <div id="modal-content" class="modal-content">
                <!-- Dynamic Content -->
            </div>
        </div>

        <div id="disaster-alert">âš ï¸ å¤©ç½é è­¦ï¼</div>
        <canvas id="board" width="600" height="600"></canvas>
    </div>

    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js';
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js';
        import { getFirestore, doc, setDoc, onSnapshot } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js';

        // Firebase Config
        const firebaseConfig = {
            apiKey: "AIzaSyACGrG89M5AlJSJmzU9v7PEOXqNMK-zKr0",
            authDomain: "gomoku-love-game.firebaseapp.com",
            projectId: "gomoku-love-game",
            storageBucket: "gomoku-love-game.firebasestorage.app",
            messagingSenderId: "488500423250",
            appId: "1:488500423250:web:f83df27227ac8bc89b8d8b"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // Use global variable attached to window to avoid scope issues
        window.currentUserId = null;

        // --- Data Init ---
        window.dowryCount = 0;
        window.ownedSkins = ['classic'];
        window.selectedSkin = 'classic';

        // Auth
        const initAuth = async () => {
            try {
                // Try anonymous login for simplicity in standalone
                await signInAnonymously(auth);
            } catch (e) {
                console.warn("Auth failed, running offline:", e);
                // Fallback to local storage data immediately if auth fails
                window.dowryCount = parseInt(localStorage.getItem('dowryCount')) || 0;
                window.ownedSkins = JSON.parse(localStorage.getItem('ownedSkins')) || ['classic'];
                window.selectedSkin = localStorage.getItem('selectedSkin') || 'classic';
                updateUIElements();
            }
        };
        initAuth();

        onAuthStateChanged(auth, (user) => {
            if (user) {
                window.currentUserId = user.uid;
                loadUserData();
            }
        });

        function loadUserData() {
            if (!window.currentUserId) return;
            const docRef = doc(db, 'users', window.currentUserId);
            onSnapshot(docRef, (docSnap) => {
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    window.dowryCount = data.dowryCount || 0;
                    window.ownedSkins = data.ownedSkins || ['classic'];
                    window.selectedSkin = data.selectedSkin || 'classic';
                } else {
                    setDoc(docRef, {
                        dowryCount: 0,
                        ownedSkins: ['classic'],
                        selectedSkin: 'classic'
                    });
                }
                updateUIElements();
            });
        }

        // Save Data
        window.updateStorage = async function () {
            // Always save to local storage as backup
            localStorage.setItem('dowryCount', window.dowryCount);
            localStorage.setItem('ownedSkins', JSON.stringify(window.ownedSkins));
            localStorage.setItem('selectedSkin', window.selectedSkin);

            if (!window.currentUserId) return;
            const docRef = doc(db, 'users', window.currentUserId);
            await setDoc(docRef, {
                dowryCount: window.dowryCount,
                ownedSkins: window.ownedSkins,
                selectedSkin: window.selectedSkin
            }, { merge: true });
            updateUIElements();
        }

        function updateUIElements() {
            const dowryEl = document.getElementById('dowry-count');
            if (dowryEl) dowryEl.textContent = window.dowryCount;
            const storeDowryEl = document.getElementById('store-dowry');
            if (storeDowryEl) storeDowryEl.textContent = window.dowryCount;
            if (typeof window.draw === 'function') window.draw();
        }

        // --- Game Globals ---
        const canvas = document.getElementById('board');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('game-container');
        const modalOverlay = document.getElementById('modal-overlay');
        const modalContent = document.getElementById('modal-content');
        const modeSelect = document.getElementById('game-mode');
        const levelSelect = document.getElementById('ai-level');
        const disasterToggle = document.getElementById('disaster-toggle');
        const disasterAlert = document.getElementById('disaster-alert');
        const startOverlay = document.getElementById('start-overlay');
        const startRunner = document.getElementById('start-runner');
        const tournamentOverlay = document.getElementById('tournament-overlay');
        const tournamentGrid = document.getElementById('tournament-grid');
        const startBtn = document.getElementById('start-btn');
        const restartBtn = document.getElementById('restart-btn');

        const imgHaha = new Image();
        imgHaha.src = 'https://popokoko.github.io/images/box_Q_YA__haha-removebg-preview.png';
        const imgLove = new Image();
        imgLove.src = 'https://popokoko.github.io/images/images/box_Q_YA__loveu-removebg-preview.png';
        const imgOnlyLove = new Image();
        imgOnlyLove.src = 'https://popokoko.github.io/images/only_love.png';
        const customImage = new Image();
        customImage.src = 'https://popokoko.github.io/mywife.png';

        const GRID_SIZE = 15;
        let CELL_SIZE = 600 / (GRID_SIZE + 1);
        let PADDING = CELL_SIZE;

        // Ensure board is initialized immediately
        let board = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));

        let currentPlayer = 1;
        let isGameOver = false;
        let lastMove = null;
        let isThinking = false;
        let isGameActive = false;
        let currentTournamentLevel = 0;
        let isInputBlocked = false;
        let skillUsageCount = 0;

        let disasterTimeoutId = null;
        let particles = [];
        let activeEffects = [];
        let animationFrameId = null;

        const skins = {
            'classic': { name: 'ç¶“å…¸é»‘ç™½', price: 0, type: 'color', color1: ['#554444', '#1a1a1a'], color2: ['#fff', '#f0e0e0'] },
            'pink': { name: 'æ«»èŠ±ç²‰ç³»', price: 50, type: 'shape', shape: 'flower', color1: '#ff69b4', color2: '#ffb6c1' },
            'galaxy': { name: 'ç’€ç’¨æ˜Ÿç©º', price: 120, type: 'shape', shape: 'star', color1: '#191970', color2: '#ffd700' },
            'heart': { name: 'ç†±æˆ€æ„›å¿ƒ', price: 360, type: 'shape', shape: 'heart', color1: '#ff0000', color2: '#ffc0cb' },
            'cat': { name: 'èŒèŒè²“æŒ', price: 520, type: 'pattern', pattern: 'paw', color1: '#8b4513', color2: '#ffe4c4' }
        };

        const tournamentSkills = [
            { name: "ç™¼å‘†", desc: "å¶çˆ¾æœƒåˆ†å¿ƒï¼Œä¸‹éŒ¯ä½ç½® (10%)" },
            { name: "æ·šçœ¼", desc: "è®“æ£‹ç›¤æ¨¡ç³Šä¸æ¸… 3 ç§’" },
            { name: "åæ‚”", desc: "è¼¾è½‰é›£çœ ï¼Œå¼·åˆ¶è¦ä½ é‡ä¸‹ä¸€å­" },
            { name: "è¿·éœ§", desc: "æ£‹ç›¤éš¨æ©Ÿå‡ºç¾è¿·éœ§é®æ“‹è¦–ç·š" },
            { name: "å¿ƒç‰†", desc: "éš¨æ©Ÿç”¢ç”Ÿ 2 å€‹éšœç¤™ç‰©" },
            { name: "éœ¹é‚", desc: "éš¨æ©Ÿæ‘§æ¯€ä½ çš„ä¸€é¡†æ£‹å­" },
            { name: "å‡çµ", desc: "æš«åœä½ çš„æ“ä½œ 2 ç§’" },
            { name: "æ··äº‚", desc: "å°‡ä½ çš„ä¸€é¡†æ£‹å­è®Šæˆæˆ‘çš„" },
            { name: "æš´é¢¨", desc: "å¬å–šé¾æ²é¢¨æ‘§æ¯€å€åŸŸ" },
            { name: "å”¯æ„›", desc: "å¬å–š Only Love é™è‡¨ä½”æ“šæ£‹ç›¤" }
        ];

        // --- Functions ---

        function init() {
            const dpr = window.devicePixelRatio || 1;
            canvas.width = 600 * dpr;
            canvas.height = 600 * dpr;
            ctx.scale(dpr, dpr);
            CELL_SIZE = 600 / (GRID_SIZE + 1);
            PADDING = CELL_SIZE;

            board = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
            updateUI();
            draw();

            canvas.addEventListener('click', handleInput);
            canvas.addEventListener('touchend', (e) => { e.preventDefault(); handleInput(e.changedTouches[0]); }, { passive: false });

            modeSelect.addEventListener('change', () => {
                const mode = modeSelect.value;
                if (mode === 'pve') { levelSelect.style.display = 'inline-block'; startBtn.textContent = "ğŸ’– é–‹å§‹å°æˆ°"; }
                else if (mode === 'tournament') { levelSelect.style.display = 'none'; startBtn.textContent = "ğŸ† é¸æ“‡å°æ‰‹"; }
                else { levelSelect.style.display = 'none'; startBtn.textContent = "ğŸ’– é–‹å§‹å°æˆ°"; }
                if (isGameActive) window.resetGame();
            });

            disasterToggle.addEventListener('change', () => {
                if (isGameActive) { if (disasterToggle.checked) scheduleNextDisaster(); else clearTimeout(disasterTimeoutId); }
            });
            animate();
        }

        window.init = init;

        window.reselectGame = function () {
            isGameActive = false; isGameOver = false; restartBtn.disabled = true; clearTimeout(disasterTimeoutId); modalOverlay.style.display = 'none'; startOverlay.style.display = 'flex'; tournamentOverlay.style.display = 'none';
            board = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0)); activeEffects = []; particles = []; lastMove = null; gameContainer.classList.remove('blur-effect', 'freeze-effect'); document.querySelectorAll('.fog-cloud').forEach(el => el.remove()); draw();
        };

        window.handleStartButtonClick = function () {
            if (modeSelect.value === 'tournament') showTournamentSelection(); else startStandardGame();
        };

        window.showTournamentSelection = showTournamentSelection;
        function showTournamentSelection() {
            startOverlay.style.display = 'none';
            tournamentOverlay.style.display = 'flex';
            generateTournamentOpponents();
        }

        window.cancelTournament = cancelTournament;
        function cancelTournament() {
            tournamentOverlay.style.display = 'none';
            startOverlay.style.display = 'flex';
        }

        function generateTournamentOpponents() {
            tournamentGrid.innerHTML = '';
            const prefixes = ["å¾®é¢¨", "ç´°é›¨", "é™°å¤©", "å¤šé›²", "é™£é›¨", "é›·é›¨", "è±ªé›¨", "é¢±é¢¨", "æµ·å˜¯", "æœ«æ—¥"];
            const moods = ["æ·¡æ·¡çš„æƒ³å¿µ", "å¶çˆ¾æƒ³èµ·å¦³", "æœ‰é»å­¤å–®", "ç¸½æ˜¯æ›å¿µå¦³", "çªç„¶å¥½æƒ³å¦³", "æ€å¿µå¦‚æ½®æ°´", "å¾¹å¤œé›£çœ ", "å‘¼å–Šå¦³åå­—", "æ²’å¦³æ´»ä¸äº†", "æ„›å¦³æ„›åˆ°æ­»"];

            for (let i = 1; i <= 10; i++) {
                const card = document.createElement('div');
                card.className = 'opponent-card';
                card.onclick = () => startTournamentMatch(i);
                const skill = tournamentSkills[i - 1];
                card.innerHTML = `
                    <div class="opponent-header"><span class="opponent-level">Level ${i}</span></div>
                    <div class="opponent-name">${prefixes[i - 1]}ç´šæƒ³å¿µ</div>
                    <div class="opponent-desc">${moods[i - 1]}</div>
                    <div class="opponent-skill"><strong>æŠ€èƒ½ï¼š${skill.name}</strong>${skill.desc}</div>
                `;
                tournamentGrid.appendChild(card);
            }
        }

        window.startTournamentMatch = startTournamentMatch;
        function startTournamentMatch(level) {
            currentTournamentLevel = level;
            tournamentOverlay.style.display = 'none';
            let aiDifficulty = 1;
            if (level >= 4 && level <= 7) aiDifficulty = 2;
            if (level >= 8) aiDifficulty = 3;
            levelSelect.value = aiDifficulty;
            runStartAnimation();
            isGameActive = true;
            restartBtn.disabled = false;
            resetGame(true);
        }

        function startStandardGame() {
            startOverlay.style.display = 'none';
            currentTournamentLevel = 0;
            isGameActive = true;
            restartBtn.disabled = false;
            runStartAnimation();
            resetGame();
        }

        function runStartAnimation() {
            startRunner.classList.remove('active');
            void startRunner.offsetWidth;
            startRunner.classList.add('active');
            setTimeout(() => { startRunner.classList.remove('active'); }, 3000);
        }

        window.resetGame = resetGame;
        function resetGame(keepState = false) {
            if (!isGameActive) return;
            board = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
            currentPlayer = 1;
            isGameOver = false;
            lastMove = null;
            isThinking = false;
            isInputBlocked = false;
            skillUsageCount = 0;
            modalOverlay.style.display = 'none';
            particles = [];
            activeEffects = [];
            gameContainer.classList.remove('blur-effect', 'freeze-effect');
            document.querySelectorAll('.fog-cloud').forEach(el => el.remove());
            clearTimeout(disasterTimeoutId);
            if (disasterToggle.checked) scheduleNextDisaster();
            draw();
            updateUI();
        }

        function updateUI() {
            const statusText = document.getElementById('status-text');
            const currentStoneIcon = document.getElementById('current-stone');
            if (!statusText || !currentStoneIcon) return;

            if (currentPlayer === 1) {
                statusText.textContent = "é»‘å­å›åˆ";
                currentStoneIcon.className = "stone-icon stone-black";
            } else {
                const mode = modeSelect.value;
                if (!isGameActive) {
                    statusText.textContent = "è«‹é»æ“Šé–‹å§‹å°æˆ°";
                } else if (mode === 'pve') {
                    statusText.textContent = "é›»è…¦æ€è€ƒä¸­...";
                } else if (mode === 'tournament') {
                    const prefixes = ["å¾®é¢¨", "ç´°é›¨", "é™°å¤©", "å¤šé›²", "é™£é›¨", "é›·é›¨", "è±ªé›¨", "é¢±é¢¨", "æµ·å˜¯", "æœ«æ—¥"];
                    const name = currentTournamentLevel > 0 ? prefixes[currentTournamentLevel - 1] + "ç´š" : "é›»è…¦";
                    statusText.textContent = `${name}æ€è€ƒä¸­...`;
                } else {
                    statusText.textContent = "ç™½å­å›åˆ";
                }
                currentStoneIcon.className = "stone-icon stone-white";
            }
        }

        window.showHelp = showHelp;
        function showHelp() {
            modalContent.innerHTML = `
                <div class="help-content">
                    <h2>ğŸŒ¸ éŠæˆ²èªªæ˜</h2>
                    <div class="help-item">
                        <h3>ğŸ¤– äººæ©Ÿå°æˆ° (PvE)</h3>
                        <p>èˆ‡ä¸åŒé›£åº¦(ç°¡å–®/æ™®é€š/å¤§å¸«)çš„é›»è…¦AIé€²è¡Œå°æˆ°ï¼Œç£¨ç·´å¦³çš„æ£‹è—ã€‚</p>
                    </div>
                    <div class="help-item">
                        <h3>ğŸ‘¥ é›™äººå°æˆ° (PvP)</h3>
                        <p>èˆ‡æœ‹å‹åœ¨åŒä¸€å°è£ç½®ä¸Šè¼ªæµä¸‹æ£‹ï¼Œäº«å—é¢å°é¢çš„æ¨‚è¶£ã€‚</p>
                    </div>
                    <div class="help-item">
                        <h3>ğŸ† æˆ‘æƒ³å¦³å¤§è³½ (Tournament)</h3>
                        <p>æŒ‘æˆ° 10 å€‹ä¸åŒç­‰ç´šçš„å°æ‰‹ï¼ç²å‹å¯å¾—å«å¦ï¼<br>
                        <span style="color:#ff1493">â˜… å† è» (Lv10): 520 å«å¦</span><br>
                        <span style="color:#ff1493">â˜… äºè» (Lv9): 360 å«å¦</span><br>
                        <span style="color:#ff1493">â˜… å­£è» (Lv8): 225 å«å¦</span><br>
                        <span>â˜… å…¶ä»–ç­‰ç´š: 10 å«å¦</span>
                        </p>
                    </div>
                    <button class="btn-secondary" style="width:100%; margin-top:10px;" onclick="window.closeModal()">çŸ¥é“äº†ï¼</button>
                </div>
            `;
            modalOverlay.style.display = 'flex';
        }

        window.showStore = showStore;
        function showStore() {
            let itemsHtml = '';
            for (const [id, skin] of Object.entries(skins)) {
                const owned = window.ownedSkins.includes(id);
                const active = window.selectedSkin === id;
                let btnText = owned ? (active ? "å·²è£å‚™" : "è£å‚™") : `è³¼è²· $${skin.price}`;
                let btnClass = owned ? (active ? "store-btn" : "store-btn btn-secondary") : "store-btn";
                let btnAction = owned ? `window.equipSkin('${id}')` : `window.buySkin('${id}', ${skin.price}, '${skin.name}')`;
                let itemClass = active ? "store-item active" : "store-item";

                let previewStyle = "";
                if (skin.type === 'color') {
                    previewStyle = `background: radial-gradient(circle at 30% 30%, ${skin.color1[0]}, ${skin.color1[1]});`;
                } else if (skin.shape === 'flower') {
                    previewStyle = `background: ${skin.color1}; clip-path: polygon(50% 0%, 80% 10%, 100% 35%, 100% 70%, 80% 90%, 50% 100%, 20% 90%, 0% 70%, 0% 35%, 20% 10%); border-radius: 50%;`;
                } else if (skin.shape === 'star') {
                    previewStyle = `background: ${skin.color1}; clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%); border-radius: 0;`;
                } else if (skin.shape === 'heart') {
                    previewStyle = `background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23ff0000'%3E%3Cpath d='M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z'/%3E%3C/svg%3E") no-repeat center/contain; border-radius: 0;`;
                } else if (skin.pattern === 'paw') {
                    previewStyle = `background: ${skin.color1}; border: 2px solid ${skin.color2}; border-radius: 50%;`;
                }

                itemsHtml += `
                    <div class="${itemClass}">
                        <div class="store-preview" style="${previewStyle}"></div>
                        <div class="store-name">${skin.name}</div>
                        <div class="store-price">${owned ? "å·²æ“æœ‰" : `$${skin.price}`}</div>
                        <button class="${btnClass}" onclick="${btnAction}" ${active ? "disabled" : ""}>${btnText}</button>
                    </div>
                `;
            }

            modalContent.innerHTML = `
                <h2 style="color:#ff1493">ğŸª æ™‚å°šå•†åŸ</h2>
                <p>ç›®å‰å«å¦: <strong id="store-dowry">${window.dowryCount}</strong> ğŸ</p>
                <div class="store-grid">
                    ${itemsHtml}
                </div>
                <button class="btn-secondary" style="width:100%; margin-top:20px;" onclick="window.closeModal()">é—œé–‰</button>
            `;
            modalOverlay.style.display = 'flex';
        }

        function showToast(msg) {
            const toast = document.getElementById('toast-message');
            toast.textContent = msg;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        window.buySkin = function (id, price, name) {
            if (window.dowryCount >= price) {
                window.dowryCount -= price;
                window.ownedSkins.push(id);
                window.updateStorage();
                window.showStore();
                showToast(`è³¼è²·æˆåŠŸï¼ç²å¾— ${name}`);
            } else {
                showToast("å«å¦ä¸è¶³ï¼å¿«å»åƒåŠ æ¯”è³½è³ºå–å§ï¼ ğŸ");
            }
        };

        window.equipSkin = function (id) {
            window.selectedSkin = id;
            window.updateStorage();
            window.showStore();
            window.draw();
        };

        window.closeModal = function () {
            modalOverlay.style.display = 'none';
        }
        function closeModal() {
            modalOverlay.style.display = 'none';
        }

        function triggerOpponentSkill() {
            if (currentTournamentLevel === 0 || isGameOver) return;
            if (Math.random() > 0.3) return;
            const skillId = currentTournamentLevel;
            const skillName = tournamentSkills[skillId - 1].name;
            const color = "#d63384";
            setTimeout(() => {
                switch (skillId) {
                    case 1: break;
                    case 2: showAlert(`æŠ€èƒ½ï¼š${skillName}!`, color); gameContainer.classList.add('blur-effect'); setTimeout(() => gameContainer.classList.remove('blur-effect'), 3000); break;
                    case 3: if (lastMove && board[lastMove.y][lastMove.x] === 1) {
                        showAlert(`æŠ€èƒ½ï¼š${skillName}!`, color);
                        board[lastMove.y][lastMove.x] = 0;
                        currentPlayer = 1; isThinking = false; draw();
                        let pos = getRandomCoordinate();
                        spawnDisasterEffect({ id: 'haha', name: 'haha' }, pos.x, pos.y);
                        updateUI();
                        return true;
                    } break;
                    case 4: showAlert(`æŠ€èƒ½ï¼š${skillName}!`, color); spawnFog(); break;
                    case 5: showAlert(`æŠ€èƒ½ï¼š${skillName}!`, color); for (let i = 0; i < 2; i++) spawnObstacle(-4); draw(); break;
                    case 6: showAlert(`æŠ€èƒ½ï¼š${skillName}!`, color); destroyRandomPlayerStone(); draw(); break;
                    case 7: showAlert(`æŠ€èƒ½ï¼š${skillName}!`, color); isInputBlocked = true; gameContainer.classList.add('freeze-effect'); setTimeout(() => { isInputBlocked = false; gameContainer.classList.remove('freeze-effect'); }, 2000); break;
                    case 8: showAlert(`æŠ€èƒ½ï¼š${skillName}!`, color); swapPlayerStoneToAI();
                        let pos8 = getRandomCoordinate();
                        spawnDisasterEffect({ id: 'haha', name: 'haha' }, pos8.x, pos8.y);
                        draw(); break;
                    case 9:
                        let pos9 = getRandomCoordinate();
                        showAlert(`æŠ€èƒ½ï¼š${skillName}!`, color);
                        spawnDisasterEffect({ id: -2, name: 'tornado' }, pos9.x, pos9.y); break;
                    case 10:
                        let pos10 = getRandomCoordinate();
                        showAlert(`æŠ€èƒ½ï¼š${skillName}!`, color);
                        spawnDisasterEffect({ id: -5, name: 'onlylove' }, pos10.x, pos10.y); break;
                }
            }, 2000);
            return false;
        }

        function spawnFog() { for (let i = 0; i < 3; i++) { const fog = document.createElement('div'); fog.className = 'fog-cloud'; fog.style.left = Math.random() * 80 + '%'; fog.style.top = Math.random() * 80 + '%'; gameContainer.appendChild(fog); setTimeout(() => fog.remove(), 5000); } }
        function destroyRandomPlayerStone() { let playerStones = []; for (let y = 0; y < GRID_SIZE; y++) for (let x = 0; x < GRID_SIZE; x++) if (board[y][x] === 1) playerStones.push({ x, y }); if (playerStones.length > 0) { const target = playerStones[Math.floor(Math.random() * playerStones.length)]; board[target.y][target.x] = -1; spawnParticles(PADDING + target.x * CELL_SIZE, PADDING + target.y * CELL_SIZE, 'meteor'); } }
        function spawnObstacle(typeId) { let x, y; do { x = Math.floor(Math.random() * GRID_SIZE); y = Math.floor(Math.random() * GRID_SIZE); } while (board[y][x] !== 0); board[y][x] = typeId; }
        function swapPlayerStoneToAI() { let playerStones = []; for (let y = 0; y < GRID_SIZE; y++) for (let x = 0; x < GRID_SIZE; x++) if (board[y][x] === 1) playerStones.push({ x, y }); if (playerStones.length > 0) { const target = playerStones[Math.floor(Math.random() * playerStones.length)]; board[target.y][target.x] = 2; } }

        function scheduleNextDisaster() {
            if (isGameOver || !disasterToggle.checked || !isGameActive) return;
            // èª¿æ•´æ™‚é–“ï¼š15000ms (15ç§’) + 0~20000ms (0~20ç§’) = 15~35ç§’
            const delay = Math.floor(Math.random() * 20000) + 15000;
            disasterTimeoutId = setTimeout(() => {
                triggerDisaster();
                scheduleNextDisaster();
            }, delay);
        }

        function triggerDisaster() { if (isGameOver || !isGameActive) return; const x = Math.floor(Math.random() * GRID_SIZE); const y = Math.floor(Math.random() * GRID_SIZE); const types = [{ id: -1, name: 'meteor', text: 'ğŸ”¥ éš•çŸ³è¡æ“Šï¼', color: '#FF4500' }, { id: -2, name: 'tornado', text: 'ğŸŒªï¸ é¾æ²é¢¨ä¾†è¥²ï¼', color: '#00FFFF' }, { id: -3, name: 'love', text: 'ğŸ’– è€å©†é™è‡¨ï¼', color: '#FF69B4' }, { id: -4, name: 'tear', text: 'ğŸ’§ ç›¸æ€æˆç½...', color: '#4169E1' }]; const disaster = types[Math.floor(Math.random() * types.length)]; spawnDisasterEffect(disaster, x, y); showAlert(disaster.text, disaster.color); }

        function spawnDisasterEffect(disaster, gridX, gridY) {
            const targetX = PADDING + gridX * CELL_SIZE;
            const targetY = PADDING + gridY * CELL_SIZE;

            let visualType = disaster.name;
            if (disaster.name === 'love' || disaster.id === -3) visualType = 'love';
            if (disaster.name === 'onlylove' || disaster.id === -5) visualType = 'onlylove';
            if (disaster.name === 'haha') visualType = 'haha';

            activeEffects.push({
                type: visualType,
                gridX: gridX,
                gridY: gridY,
                disasterId: disaster.id,
                progress: 0,
                x: visualType === 'meteor' || visualType === 'love' || visualType === 'tear' || visualType === 'onlylove' ? targetX : targetX - 100,
                y: visualType === 'meteor' || visualType === 'love' || visualType === 'tear' || visualType === 'onlylove' ? -50 : targetY,
                targetX: targetX,
                targetY: targetY
            });
        }

        function applyDisasterDamage(effect) {
            if (typeof effect.disasterId === 'number') {
                board[effect.gridY][effect.gridX] = effect.disasterId;
            }
            gameContainer.classList.remove('shake-effect');
            void gameContainer.offsetWidth;
            gameContainer.classList.add('shake-effect');
            spawnParticles(effect.targetX, effect.targetY, effect.type);
        }

        function spawnParticles(x, y, type) { let count = 20; let color = '#fff'; if (type === 'meteor') { count = 30; color = '#ffaa00'; } else if (type === 'tornado') { count = 20; color = '#88ffff'; } else if (type === 'love') { count = 15; color = '#ff69b4'; } else if (type === 'tear') { count = 15; color = '#4169e1'; } for (let i = 0; i < count; i++) { particles.push({ x: x, y: y, vx: (Math.random() - 0.5) * 10, vy: (Math.random() - 0.5) * 10, life: 1.0, color: color, type: type }); } }
        function drawParticles() { particles.forEach(p => { ctx.globalAlpha = p.life; ctx.fillStyle = p.color; ctx.beginPath(); if (p.type === 'love') { ctx.font = "12px Arial"; ctx.fillText("â¤", p.x, p.y); } else if (p.type === 'tornado') { ctx.rect(p.x, p.y, 3, 3); ctx.fill(); } else { ctx.arc(p.x, p.y, 3, 0, Math.PI * 2); ctx.fill(); } }); ctx.globalAlpha = 1.0; }
        function showAlert(text, color) { disasterAlert.textContent = text; disasterAlert.style.color = color; disasterAlert.style.textShadow = `0 0 20px ${color}, 2px 2px 0 #000`; disasterAlert.classList.add('active'); setTimeout(() => { disasterAlert.classList.remove('active'); }, 2000); }

        function animate() {
            window.draw();
            updateEffects();
            animationFrameId = requestAnimationFrame(animate);
        }

        function updateEffects() {
            for (let i = activeEffects.length - 1; i >= 0; i--) {
                let eff = activeEffects[i];
                if (eff.type === 'meteor') { eff.y += 15; if (eff.y >= eff.targetY) { applyDisasterDamage(eff); activeEffects.splice(i, 1); } }
                else if (eff.type === 'love') { eff.y += 5; if (eff.y >= eff.targetY) { applyDisasterDamage(eff); activeEffects.splice(i, 1); } }
                else if (eff.type === 'onlylove') { eff.y += 3; if (eff.y >= eff.targetY) { applyDisasterDamage(eff); activeEffects.splice(i, 1); } }
                else if (eff.type === 'tear') { eff.y += 8; if (eff.y >= eff.targetY) { applyDisasterDamage(eff); activeEffects.splice(i, 1); } }
                else if (eff.type === 'tornado') { eff.x += (eff.targetX - eff.x) * 0.1; eff.progress += 0.05; if (Math.abs(eff.x - eff.targetX) < 5 && eff.progress > 1) { applyDisasterDamage(eff); activeEffects.splice(i, 1); } }
                else if (eff.type === 'haha') { eff.y -= 2; eff.progress += 0.05; if (eff.progress > 2) { activeEffects.splice(i, 1); } }
            }
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i]; p.x += p.vx; p.y += p.vy; p.life -= 0.02; if (p.type === 'tear' || p.type === 'meteor') p.vy += 0.2; if (p.life <= 0) { particles.splice(i, 1); }
            }
        }

        function draw() {
            ctx.clearRect(0, 0, 600, 600);
            ctx.beginPath(); ctx.lineWidth = 1; ctx.strokeStyle = "#8B4C5E";
            for (let i = 0; i < GRID_SIZE; i++) { ctx.moveTo(PADDING, PADDING + i * CELL_SIZE); ctx.lineTo(PADDING + (GRID_SIZE - 1) * CELL_SIZE, PADDING + i * CELL_SIZE); ctx.moveTo(PADDING + i * CELL_SIZE, PADDING); ctx.lineTo(PADDING + i * CELL_SIZE, PADDING + (GRID_SIZE - 1) * CELL_SIZE); } ctx.stroke();
            const stars = [{ x: 3, y: 3 }, { x: 11, y: 3 }, { x: 7, y: 7 }, { x: 3, y: 11 }, { x: 11, y: 11 }]; ctx.fillStyle = "#8B4C5E"; stars.forEach(star => { ctx.beginPath(); ctx.arc(PADDING + star.x * CELL_SIZE, PADDING + star.y * CELL_SIZE, 4, 0, Math.PI * 2); ctx.fill(); });

            if (!board || board.length === 0) return;

            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const val = board[y][x];
                    if (val > 0) drawStone(x, y, val);
                    else if (val < 0) drawDisasterResult(x, y, val);
                }
            }
            if (lastMove && board[lastMove.y][lastMove.x] > 0) { ctx.beginPath(); const cx = PADDING + lastMove.x * CELL_SIZE; const cy = PADDING + lastMove.y * CELL_SIZE; ctx.fillStyle = "#ff1493"; ctx.fillRect(cx - 4, cy - 4, 8, 8); }
            drawActiveEffects(); drawParticles();
        }

        function drawActiveEffects() {
            activeEffects.forEach(eff => {
                ctx.save();
                ctx.translate(eff.x, eff.y);
                if (eff.type === 'meteor') { const grad = ctx.createRadialGradient(0, 0, 5, 0, 0, 20); grad.addColorStop(0, '#ffff00'); grad.addColorStop(0.5, '#ffaa00'); grad.addColorStop(1, 'transparent'); ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(0, 0, 20, 0, Math.PI * 2); ctx.fill(); }
                else if (eff.type === 'tornado') { ctx.rotate(Date.now() / 100); ctx.strokeStyle = "rgba(0, 255, 255, 0.6)"; ctx.lineWidth = 3; ctx.beginPath(); for (let i = 0; i < 3; i++) { ctx.arc(0, i * 5, 10 + i * 5, 0, Math.PI); } ctx.stroke(); }
                else if (eff.type === 'love') { if (imgLove.complete && imgLove.naturalWidth !== 0) { ctx.drawImage(imgLove, -30, -30, 60, 60); } else { ctx.fillStyle = "#FF1493"; ctx.font = "30px Arial"; ctx.fillText("â¤", -15, 10); } }
                else if (eff.type === 'onlylove') { if (imgOnlyLove.complete && imgOnlyLove.naturalWidth !== 0) { ctx.drawImage(imgOnlyLove, -50, -50, 100, 100); } else { ctx.fillStyle = "#FF1493"; ctx.fillText("Only Love", -30, 0); } }
                else if (eff.type === 'tear') { ctx.fillStyle = "#00BFFF"; ctx.font = "30px Arial"; ctx.fillText("ğŸ’§", -15, 10); }
                else if (eff.type === 'haha') { if (imgHaha.complete && imgHaha.naturalWidth !== 0) { ctx.drawImage(imgHaha, -40, -40, 80, 80); } else { ctx.fillStyle = "#FF1493"; ctx.font = "30px Arial"; ctx.fillText("Haha", -25, 10); } }
                ctx.restore();
            });
        }

        function drawDisasterResult(x, y, type) {
            const cx = PADDING + x * CELL_SIZE;
            const cy = PADDING + y * CELL_SIZE;
            const size = CELL_SIZE * 0.4;
            ctx.save();
            ctx.translate(cx, cy);

            if (type === -1) { /* ... meteor ... */ ctx.fillStyle = "#444"; ctx.beginPath(); ctx.arc(0, 0, size, 0, Math.PI * 2); ctx.fill(); ctx.strokeStyle = "#FF4500"; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(-size * 0.7, -size * 0.7); ctx.lineTo(size * 0.7, size * 0.7); ctx.moveTo(size * 0.7, -size * 0.7); ctx.lineTo(-size * 0.7, size * 0.7); ctx.stroke(); }
            else if (type === -2) { /* ... tornado ... */ ctx.fillStyle = "#aaa"; ctx.beginPath(); ctx.arc(0, 0, size * 0.8, 0, Math.PI * 2); ctx.fill(); ctx.strokeStyle = "#555"; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(0, 0, size * 0.5, 0, Math.PI * 1.5); ctx.stroke(); }
            else if (type === -3) { /* ... mywife ... */ if (customImage.complete && customImage.naturalWidth !== 0) { ctx.beginPath(); ctx.arc(0, 0, size * 1.2, 0, Math.PI * 2); ctx.clip(); ctx.drawImage(customImage, -size * 1.2, -size * 1.2, size * 2.4, size * 2.4); } else { ctx.fillStyle = "#FF69B4"; ctx.beginPath(); const topCurveHeight = size * 0.3; ctx.moveTo(0, topCurveHeight); ctx.bezierCurveTo(0, 0, -size, 0, -size, topCurveHeight); ctx.bezierCurveTo(-size, (size + topCurveHeight) / 2, 0, size, 0, size + topCurveHeight); ctx.bezierCurveTo(0, size, size, (size + topCurveHeight) / 2, size, topCurveHeight); ctx.bezierCurveTo(size, 0, 0, 0, 0, topCurveHeight); ctx.fill(); } }
            else if (type === -4) { /* ... tear ... */ ctx.fillStyle = "#4169E1"; ctx.beginPath(); ctx.arc(0, size * 0.4, size * 0.6, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.moveTo(0, -size); ctx.quadraticCurveTo(size * 0.6, size * 0.4, 0, size * 0.4); ctx.quadraticCurveTo(-size * 0.6, size * 0.4, 0, -size); ctx.fill(); }
            else if (type === -5) { // Only Love (Level 10)
                if (imgOnlyLove.complete && imgOnlyLove.naturalWidth !== 0) {
                    // Draw circular clipped image for Only Love
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 1.5, 0, Math.PI * 2);
                    ctx.clip();
                    ctx.drawImage(imgOnlyLove, -size * 1.5, -size * 1.5, size * 3, size * 3);
                } else {
                    ctx.fillStyle = "#FF1493";
                    ctx.fillText("Only Love", -20, 5);
                }
            }
            ctx.restore();
        }

        function drawStone(x, y, type) {
            const cx = PADDING + x * CELL_SIZE;
            const cy = PADDING + y * CELL_SIZE;
            const radius = CELL_SIZE * 0.45;

            let currentStyle = skins['classic'];

            if (type === 1) {
                let skinKey = window.selectedSkin;
                if (!skins[skinKey]) skinKey = 'classic';
                currentStyle = skins[skinKey];
            } else {
                currentStyle = { type: 'color', color1: ['#fff', '#f0e0e0'] };
            }

            if (currentStyle.type === 'color') {
                ctx.beginPath();
                ctx.arc(cx, cy, radius, 0, Math.PI * 2);
                ctx.shadowColor = "rgba(0, 0, 0, 0.2)"; ctx.shadowBlur = 5; ctx.shadowOffsetX = 2; ctx.shadowOffsetY = 2;
                const grad = ctx.createRadialGradient(cx - radius / 3, cy - radius / 3, radius / 10, cx, cy, radius);
                grad.addColorStop(0, currentStyle.color1[0]);
                grad.addColorStop(1, currentStyle.color1[1]);
                ctx.fillStyle = grad;
                ctx.fill();
            } else if (currentStyle.type === 'shape') {
                ctx.shadowColor = "rgba(0, 0, 0, 0.2)"; ctx.shadowBlur = 5; ctx.shadowOffsetX = 2; ctx.shadowOffsetY = 2;
                ctx.fillStyle = currentStyle.color1;

                if (currentStyle.shape === 'flower') {
                    const petalRadius = radius * 0.5;
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * 2 * Math.PI) / 5 - (Math.PI / 2);
                        const px = cx + Math.cos(angle) * (radius * 0.4);
                        const py = cy + Math.sin(angle) * (radius * 0.4);
                        ctx.beginPath();
                        ctx.arc(px, py, petalRadius, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.fillStyle = "#fff";
                    ctx.beginPath();
                    ctx.arc(cx, cy, radius * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                } else if (currentStyle.shape === 'star') {
                    ctx.beginPath();
                    const spikes = 5;
                    const outerRadius = radius;
                    const innerRadius = radius * 0.5;
                    let rot = Math.PI / 2 * 3;
                    let x = cx;
                    let y = cy;
                    let step = Math.PI / spikes;

                    ctx.moveTo(cx, cy - outerRadius);
                    for (let i = 0; i < spikes; i++) {
                        x = cx + Math.cos(rot) * outerRadius;
                        y = cy + Math.sin(rot) * outerRadius;
                        ctx.lineTo(x, y);
                        rot += step;

                        x = cx + Math.cos(rot) * innerRadius;
                        y = cy + Math.sin(rot) * innerRadius;
                        ctx.lineTo(x, y);
                        rot += step;
                    }
                    ctx.lineTo(cx, cy - outerRadius);
                    ctx.closePath();
                    ctx.fill();
                } else if (currentStyle.shape === 'heart') {
                    ctx.beginPath();
                    const size = radius;
                    const topCurveHeight = size * 0.3;
                    ctx.save();
                    ctx.translate(cx, cy - size / 2);
                    ctx.moveTo(0, topCurveHeight);
                    ctx.bezierCurveTo(0, 0, -size, 0, -size, topCurveHeight);
                    ctx.bezierCurveTo(-size, (size + topCurveHeight) / 2, 0, size, 0, size + topCurveHeight);
                    ctx.bezierCurveTo(0, size, size, (size + topCurveHeight) / 2, size, topCurveHeight);
                    ctx.bezierCurveTo(size, 0, 0, 0, 0, topCurveHeight);
                    ctx.fill();
                    ctx.restore();
                }
            } else if (currentStyle.type === 'pattern' && currentStyle.pattern === 'paw') {
                ctx.shadowColor = "rgba(0, 0, 0, 0.2)"; ctx.shadowBlur = 5; ctx.shadowOffsetX = 2; ctx.shadowOffsetY = 2;
                ctx.fillStyle = currentStyle.color1;
                ctx.beginPath();
                ctx.ellipse(cx, cy + 3, radius * 0.5, radius * 0.4, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = currentStyle.color2;
                for (let i = -1.5; i <= 1.5; i += 1) {
                    ctx.beginPath();
                    ctx.arc(cx + i * 10, cy - 8 - Math.abs(i) * 3, radius * 0.18, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            ctx.shadowColor = "transparent";
        }

        function endGame(winner) {
            isGameOver = true;
            clearTimeout(disasterTimeoutId);
            let msg = winner === 1 ? "é»‘å­ç²å‹!" : "ç™½å­ç²å‹!";
            const mode = modeSelect.value;
            let reward = 0;
            let extraHtml = '';

            if ((mode === 'pve' || mode === 'tournament') && winner === 2) {
                msg = mode === 'tournament' ? "æ€å¿µå¤ªå¼·ï¼Œå¦³è¼¸äº†ï¼" : "é›»è…¦ç²å‹!";
            } else if (winner === 1 && mode === 'tournament') {
                if (currentTournamentLevel === 10) {
                    reward = 520;
                    extraHtml = `<img src="https://popokoko.github.io/images/only_love.png" style="max-width: 100%; height: auto; border-radius: 15px; margin-bottom: 15px; border: 2px solid #ff69b4; box-shadow: 0 0 15px #ffb6c1;">`;
                }
                else if (currentTournamentLevel === 9) reward = 360;
                else if (currentTournamentLevel === 8) reward = 225;
                else reward = 10;

                msg = `æ­å–œç²å‹ï¼<br>ç²å¾— ${reward} å€‹å«å¦ ğŸ`;
                window.dowryCount += reward;
                window.updateStorage();
            }

            modalContent.innerHTML = `
                ${extraHtml}
                <div id="winner-text">${winner === 1 ? "ğŸ‰ æ­å–œç²å‹!" : "ğŸ’” å†æ¥å†å²"}</div>
                ${reward > 0 ? `<div id="reward-text">ğŸ +${reward} å«å¦</div>` : ''}
                <p style="color:#666; margin-bottom:20px;">${winner === 1 ? "å¦³çš„æ„›æ„æˆ°å‹äº†ä¸€åˆ‡ï¼" : "ä¸è¦æ°£é¤’ï¼Œæ„›éœ€è¦å …æŒï¼"}</p>
                <button class="btn-secondary" onclick="window.closeModal(); window.resetGame();">å†ä¾†ä¸€å±€</button>
                ${mode === 'tournament' ? `<button class="btn-secondary" style="margin-top:10px" onclick="window.closeModal(); window.showTournamentSelection();">é¸æ“‡å°æ‰‹</button>` : ''}
            `;
            modalOverlay.style.display = 'flex';
            const statusText = document.getElementById('status-text');
            if (statusText) statusText.textContent = "éŠæˆ²çµæŸ";
        }

        // --- EXPORTING GLOBAL FUNCTIONS FOR HTML BUTTONS ---
        window.init = init;
        window.draw = draw;
        window.resetGame = resetGame;
        window.reselectGame = reselectGame;
        window.handleStartButtonClick = handleStartButtonClick;
        window.showTournamentSelection = showTournamentSelection;
        window.cancelTournament = cancelTournament;
        window.startTournamentMatch = startTournamentMatch;
        window.showStore = showStore;
        window.showHelp = showHelp;
        window.closeModal = closeModal;
        window.updateStorage = updateStorage;
        window.buySkin = buySkin;
        window.equipSkin = equipSkin;

    </script>
</body>

</html>
